AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to deploy Security Group remediation Lambda with EventBridge trigger'

Parameters:
  InternalCIDRRanges:
    Type: String
    Description: 'Comma-separated list of internal CIDR ranges (e.g., "10.0.0.0/16,10.1.0.0/16")'
    Default: '10.0.0.0/16,10.1.0.0/16'
  IsStackSetExecution:
    Type: String
    Description: 'Is this template being deployed via StackSet'
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
  AdditionalSkipPorts:
    Type: String
    Description: 'Comma-separated list of additional ports to skip remediation for load balancer security groups (e.g., "22,3389")'
    Default: ''

Conditions:
  IsStackSet: !Equals [!Ref IsStackSetExecution, 'true'] 

Mappings:
  DefaultTags:
    Tags:
      CreatedMethod: "CloudFormation"

Resources:
  SecurityGroupRemediationLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: security-group-remediation
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import os
          import time
          
          # Initialize clients
          ec2 = boto3.client('ec2')
          elbv2 = boto3.client('elbv2')
          elb = boto3.client('elb')
          
          def is_event_from_remediation(event):
              """Check if the event was generated by our remediation Lambda"""
              try:
                  user_identity = event.get('detail', {}).get('userIdentity', {})
                  if user_identity.get('principalId', '').endswith(':security-group-remediation'):
                      print("Event was generated by remediation Lambda")
                      return True
                  return False
              except Exception as e:
                  print(f"Error checking event source: {str(e)}")
                  return False
          
          def get_internal_cidr_ranges():
              """Get internal CIDR ranges from environment variable"""
              cidr_ranges_str = os.environ.get('INTERNAL_CIDR_RANGES', '10.0.0.0/16')
              return [cidr.strip() for cidr in cidr_ranges_str.split(',')]
          
          def handle_lb_security_group_rule(security_group_id, permission, port, cidr_ip):
              """
              Handle rules for load balancer security groups
              
              Args:
                  security_group_id: The ID of the security group
                  permission: The permission rule being evaluated
                  port: The port number being evaluated
                  cidr_ip: The CIDR IP range of the rule
                  
              Returns:
                  action: str - Either 'revoke' or 'skip'
              """
              # Only process rules with 0.0.0.0/0
              if cidr_ip != '0.0.0.0/0':
                  print(f"Skipping rule with CIDR {cidr_ip} as it's not 0.0.0.0/0")
                  return 'skip'
          
              # For load balancer security groups, only allow HTTP/HTTPS ports and custom ports
              allowed_ports = {80, 443}  # Default allowed ports for LBs
              
              # Add any custom allowed ports
              additional_ports_str = os.environ.get('ADDITIONAL_SKIP_PORTS', '')
              if additional_ports_str:
                  try:
                      additional_ports = {int(port_str.strip()) for port_str in additional_ports_str.split(',') if port_str.strip()}
                      allowed_ports.update(additional_ports)
                  except ValueError as e:
                      print(f"Error parsing additional skip ports: {str(e)}")
              
              if port is None or permission['IpProtocol'] == '-1':  # Rule applies to all ports or all protocols
                  print("Load balancer security group has all-ports/protocols rule from 0.0.0.0/0 - will revoke")
                  return 'revoke'
                  
              if port in allowed_ports:
                  print(f"Skipping allowed port {port} from 0.0.0.0/0 on load balancer security group")
                  return 'skip'
              
              print(f"Port {port} from 0.0.0.0/0 is not in allowed list for load balancer security group - will revoke")
              return 'revoke'
          
          def is_sg_attached_to_load_balancer(security_group_id):
              """Check if security group is attached to any load balancer"""
              try:
                  # Check Application and Network Load Balancers (v2)
                  paginator = elbv2.get_paginator('describe_load_balancers')
                  try:
                      for page in paginator.paginate():
                          for lb in page['LoadBalancers']:
                              if 'SecurityGroups' in lb and security_group_id in lb['SecurityGroups']:
                                  print(f"Security group {security_group_id} is attached to ALB/NLB: {lb['LoadBalancerName']}")
                                  return True
                  except Exception as e:
                      print(f"Error checking ALB/NLB associations: {str(e)}")
          
                  # Check Classic Load Balancers
                  paginator = elb.get_paginator('describe_load_balancers')
                  try:
                      for page in paginator.paginate():
                          for lb in page['LoadBalancerDescriptions']:
                              if security_group_id in lb['SecurityGroups']:
                                  print(f"Security group {security_group_id} is attached to Classic ELB: {lb['LoadBalancerName']}")
                                  return True
                  except Exception as e:
                      print(f"Error checking Classic ELB associations: {str(e)}")
          
                  print(f"Security group {security_group_id} is not attached to any load balancer")
                  return False
          
              except Exception as e:
                  print(f"Error checking load balancer associations: {str(e)}")
                  # If we can't check, assume it's not attached to be safe
                  return False
          
          def revoke_rule(security_group_id, permission, cidr_ip):
              """
              Revoke a security group rule without adding new rules
              Returns tuple (success, error_message)
              """
              try:
                  # Handle the case where protocol is -1 (all protocols)
                  if permission['IpProtocol'] == '-1':
                      ec2.revoke_security_group_ingress(
                          GroupId=security_group_id,
                          IpPermissions=[{
                              'IpProtocol': '-1',
                              'IpRanges': [{'CidrIp': cidr_ip}]
                          }]
                      )
                  else:
                      ec2.revoke_security_group_ingress(
                          GroupId=security_group_id,
                          IpProtocol=permission['IpProtocol'],
                          FromPort=permission.get('FromPort'),
                          ToPort=permission.get('ToPort'),
                          CidrIp=cidr_ip
                      )
                  
                  print(f"Revoked rule allowing ingress from {cidr_ip} for protocol {permission['IpProtocol']}")
                  return True, None
              except Exception as e:
                  error_msg = f"Error revoking security group rule: {str(e)}"
                  print(error_msg)
                  return False, error_msg
          
          def revoke_and_authorize_rule(security_group_id, permission, cidr_ip, internal_cidr_ranges):
              """
              Revoke and authorize security group rules handling the all protocols case
              Returns tuple (success, error_message)
              """
              try:
                  # Handle the case where protocol is -1 (all protocols)
                  if permission['IpProtocol'] == '-1':
                      # For all protocols, we don't specify ports
                      ec2.revoke_security_group_ingress(
                          GroupId=security_group_id,
                          IpPermissions=[{
                              'IpProtocol': '-1',
                              'IpRanges': [{'CidrIp': cidr_ip}]
                          }]
                      )
                      print(f"Revoked rule allowing all protocols ingress from {cidr_ip}")
          
                      # Add new rules for internal CIDR ranges
                      for cidr in internal_cidr_ranges:
                          ec2.authorize_security_group_ingress(
                              GroupId=security_group_id,
                              IpPermissions=[{
                                  'IpProtocol': '-1',
                                  'IpRanges': [{'CidrIp': cidr}]
                              }]
                          )
                          print(f"Authorized rule allowing all protocols ingress from {cidr}")
                  else:
                      # For specific protocols, include port information
                      ec2.revoke_security_group_ingress(
                          GroupId=security_group_id,
                          IpProtocol=permission['IpProtocol'],
                          FromPort=permission.get('FromPort'),
                          ToPort=permission.get('ToPort'),
                          CidrIp=cidr_ip
                      )
                      print(f"Revoked rule allowing ingress from {cidr_ip} on ports "
                            f"{permission.get('FromPort') if permission.get('FromPort') is not None else 'All'} "
                            f"to {permission.get('ToPort', 'All')}.")
          
                      # Add new rules for internal CIDR ranges
                      for cidr in internal_cidr_ranges:
                          ec2.authorize_security_group_ingress(
                              GroupId=security_group_id,
                              IpProtocol=permission['IpProtocol'],
                              FromPort=permission.get('FromPort'),
                              ToPort=permission.get('ToPort'),
                              CidrIp=cidr
                          )
                          print(f"Authorized rule allowing ingress from {cidr} on ports "
                                f"{permission.get('FromPort') if permission.get('FromPort') is not None else 'All'} "
                                f"to {permission.get('ToPort', 'All')}.")
                  return True, None
              except Exception as e:
                  error_msg = f"Error modifying security group rule: {str(e)}"
                  print(error_msg)
                  return False, error_msg
          
          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")
          
              # Check if this event was generated by our remediation
              if is_event_from_remediation(event):
                  print("Skipping event as it was generated by remediation")
                  return {
                      'statusCode': 200,
                      'body': "Event was generated by remediation, skipping"
                  }
          
              # Get CIDR ranges from environment variable
              internal_cidr_ranges = get_internal_cidr_ranges()
              print(f"Using internal CIDR ranges: {internal_cidr_ranges}")
          
              # Extract security group ID from the CloudTrail event
              try:
                  if 'detail' in event:
                      event_name = event['detail']['eventName']
                      print(f"Processing event: {event_name}")
          
                      if event_name == 'CreateSecurityGroup':
                          target_sg_id = event['detail']['responseElements']['groupId']
                      elif event_name == 'ModifySecurityGroupRules':
                          target_sg_id = event['detail']['requestParameters']['ModifySecurityGroupRulesRequest']['GroupId']
                      elif event_name == 'AuthorizeSecurityGroupIngress':
                          target_sg_id = event['detail']['requestParameters']['groupId']
                      else:
                          raise ValueError(f"Unsupported event type: {event_name}")
          
                      if not target_sg_id:
                          raise ValueError("Could not determine security group ID from event")
          
                  else:
                      raise ValueError("Event does not contain detail section")
          
              except Exception as e:
                  print(f"Error extracting security group ID from event: {str(e)}")
                  return {
                      'statusCode': 400,
                      'body': f"Error processing event: {str(e)}"
                  }
          
              print(f"Target Security Group ID: {target_sg_id}")
          
              # Check if security group is attached to a load balancer
              is_lb_sg = is_sg_attached_to_load_balancer(target_sg_id)
              if is_lb_sg:
                  print(f"Security group {target_sg_id} is attached to a load balancer. Will enforce LB rules.")
          
              # Add a small delay to allow for eventual consistency
              time.sleep(2)
          
              # Describe the specific security group
              try:
                  security_group = ec2.describe_security_groups(GroupIds=[target_sg_id])
                  print(f"Successfully described security group {target_sg_id}.")
              except Exception as e:
                  print(f"Error describing security group: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': f"Error describing security group: {str(e)}"
                  }
          
              # Track remediation status and errors
              remediation_done = False
              failed_rules = []
          
              # Process security group rules
              for permission in security_group['SecurityGroups'][0]['IpPermissions']:
                  port = permission.get('FromPort')
                  print(f"Evaluating rule with protocol {permission['IpProtocol']}, "
                        f"ports {port if port is not None else 'All'} to {permission.get('ToPort', 'All')}.")
          
                  for ip_range in permission.get('IpRanges', []):
                      if ip_range['CidrIp'] == '0.0.0.0/0':
                          if is_lb_sg:
                              # For load balancer security groups
                              action = handle_lb_security_group_rule(target_sg_id, permission, port, ip_range['CidrIp'])
                              
                              if action == 'revoke':
                                  success, error = revoke_rule(target_sg_id, permission, ip_range['CidrIp'])
                              elif action == 'skip':
                                  continue
                              else:
                                  print(f"Unexpected action {action} for LB security group")
                                  continue
                                  
                          else:
                              # For non-LB security groups, proceed with normal remediation
                              success, error = revoke_and_authorize_rule(target_sg_id, permission, ip_range['CidrIp'], internal_cidr_ranges)
                          
                          if success:
                              remediation_done = True
                          else:
                              failed_rules.append({
                                  'protocol': permission['IpProtocol'],
                                  'fromPort': port,
                                  'toPort': permission.get('ToPort'),
                                  'error': error
                              })
          
              # Prepare response based on overall results
              if not remediation_done and not failed_rules:
                  print(f"No applicable rules found for remediation in security group {target_sg_id}.")
                  return {
                      'statusCode': 200,
                      'body': f"No remediation necessary for security group {target_sg_id}."
                  }
              elif failed_rules:
                  print(f"Some rules failed remediation in security group {target_sg_id}.")
                  return {
                      'statusCode': 207,  # Using 207 Multi-Status to indicate partial success
                      'body': json.dumps({
                          'message': f"Partial remediation for security group {target_sg_id}.",
                          'failed_rules': failed_rules,
                          'some_rules_succeeded': remediation_done
                      })
                  }
              else:
                  print(f"All applicable rules for security group {target_sg_id} have been remediated.")
                  return {
                      'statusCode': 200,
                      'body': f"Rules for security group {target_sg_id} have been successfully remediated."
                  }
      Environment:
        Variables:
          INTERNAL_CIDR_RANGES: !Ref InternalCIDRRanges
          ADDITIONAL_SKIP_PORTS: !Ref AdditionalSkipPorts
      Timeout: 30
      MemorySize: 128
      Tags:
        - Key: CreatedBy
          Value: !Ref 'AWS::StackName'
        - Key: StackId
          Value: !Ref 'AWS::StackId'
        - Key: StackSetName
          Value: !If [IsStackSet, !Select [0, !Split ["-", !Ref 'AWS::StackName']], "N/A"]
        - Key: CreatedMethod
          Value: !FindInMap [DefaultTags, Tags, CreatedMethod]

  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecurityGroupManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:RevokeSecurityGroupIngress
                  - ec2:AuthorizeSecurityGroupIngress
                  - elasticloadbalancing:DescribeLoadBalancers
                  - elasticloadbalancing:DescribeLoadBalancerAttributes
                  - elasticloadbalancingv2:DescribeLoadBalancers
                  - elasticloadbalancingv2:DescribeLoadBalancerAttributes
                Resource: '*'
      Tags:
        - Key: CreatedBy
          Value: !Ref 'AWS::StackName'
        - Key: StackId
          Value: !Ref 'AWS::StackId'
        - Key: StackSetName
          Value: !If [IsStackSet, !Select [0, !Split ["-", !Ref 'AWS::StackName']], "N/A"]
        - Key: CreatedMethod
          Value: !FindInMap [DefaultTags, Tags, CreatedMethod]

  SecurityGroupEventRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Name: security-group-changes
      Description: 'Capture security group modifications and creations'
      EventPattern:
        source:
          - aws.ec2
        detail-type:
          - AWS API Call via CloudTrail
        detail:
          eventSource:
            - ec2.amazonaws.com
          eventName:
            - AuthorizeSecurityGroupIngress
            - CreateSecurityGroup
            - ModifySecurityGroupRules
      State: ENABLED
      Targets:
        - Arn: !GetAtt SecurityGroupRemediationLambda.Arn
          Id: SecurityGroupRemediationTarget

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref SecurityGroupRemediationLambda
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SecurityGroupEventRule.Arn

Outputs:
  LambdaArn:
    Description: 'ARN of the created Lambda function'
    Value: !GetAtt SecurityGroupRemediationLambda.Arn
  EventRuleArn:
    Description: 'ARN of the created EventBridge rule'
    Value: !GetAtt SecurityGroupEventRule.Arn
  ConfiguredCIDRRanges:
    Description: 'Configured internal CIDR ranges'
    Value: !Ref InternalCIDRRanges
  ConfiguredSkipPorts:
    Description: 'Configured ports to skip for load balancer security groups'
    Value: !Ref AdditionalSkipPorts
