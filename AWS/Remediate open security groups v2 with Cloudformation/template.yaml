AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to deploy Security Group remediation Lambda with EventBridge trigger'

Parameters:
  InternalCIDRRanges:
    Type: String
    Description: 'Comma-separated list of internal CIDR ranges (e.g., "10.0.0.0/16,10.1.0.0/16")'
    Default: '10.0.0.0/16,10.1.0.0/16'
  IsStackSetExecution:
    Type: String
    Description: 'Is this template being deployed via StackSet'
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
  AdditionalSkipPorts:
    Type: String
    Description: 'Comma-separated list of additional ports to skip remediation for load balancer security groups (e.g., "22,3389")'
    Default: ''

Conditions:
  IsStackSet: !Equals [!Ref IsStackSetExecution, 'true'] 

Mappings:
  DefaultTags:
    Tags:
      CreatedMethod: "CloudFormation"

Resources:
  SecurityGroupRemediationLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: security-group-remediation
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import os
          import time

          # Initialize clients
          ec2 = boto3.client('ec2')
          elbv2 = boto3.client('elbv2')
          elb = boto3.client('elb')

          def is_event_from_remediation(event):
              """Check if the event was generated by our remediation Lambda"""
              try:
                  user_identity = event.get('detail', {}).get('userIdentity', {})
                  if user_identity.get('principalId', '').endswith(':security-group-remediation'):
                      print("Event was generated by remediation Lambda")
                      return True
                  return False
              except Exception as e:
                  print(f"Error checking event source: {str(e)}")
                  return False

          def get_internal_cidr_ranges():
              """Get internal CIDR ranges from environment variable"""
              cidr_ranges_str = os.environ.get('INTERNAL_CIDR_RANGES', '10.0.0.0/16')
              return [cidr.strip() for cidr in cidr_ranges_str.split(',')]

          def should_remediate_rule(is_lb_security_group, port):
              """
              Determine if a rule should be remediated based on security group type and port
              
              Args:
                  is_lb_security_group: Whether this security group is attached to a load balancer
                  port: The port number being evaluated
                  
              Returns:
                  bool: True if the rule should be remediated, False if it should be skipped
              """
              if not is_lb_security_group:
                  return True
              
              if port is None:  # Rule applies to all ports
                  return True
              
              # For load balancer security groups, check HTTP/HTTPS ports first
              if port in {80, 443}:
                  print(f"Skipping remediation for HTTP/HTTPS port {port} on load balancer security group")
                  return False
                  
              # Only check additional skip ports for load balancer security groups
              additional_ports_str = os.environ.get('ADDITIONAL_SKIP_PORTS', '')
              if additional_ports_str:
                  try:
                      additional_ports = {int(port_str.strip()) for port_str in additional_ports_str.split(',') if port_str.strip()}
                      if port in additional_ports:
                          print(f"Skipping remediation for custom allowed port {port} from template on load balancer security group")
                          return False
                  except ValueError as e:
                      print(f"Error parsing additional skip ports: {str(e)}")
              
              return True

          def is_sg_attached_to_load_balancer(security_group_id):
              """Check if security group is attached to any load balancer"""
              try:
                  # Check Application and Network Load Balancers (v2)
                  paginator = elbv2.get_paginator('describe_load_balancers')
                  try:
                      for page in paginator.paginate():
                          for lb in page['LoadBalancers']:
                              if 'SecurityGroups' in lb and security_group_id in lb['SecurityGroups']:
                                  print(f"Security group {security_group_id} is attached to ALB/NLB: {lb['LoadBalancerName']}")
                                  return True
                  except Exception as e:
                      print(f"Error checking ALB/NLB associations: {str(e)}")

                  # Check Classic Load Balancers
                  paginator = elb.get_paginator('describe_load_balancers')
                  try:
                      for page in paginator.paginate():
                          for lb in page['LoadBalancerDescriptions']:
                              if security_group_id in lb['SecurityGroups']:
                                  print(f"Security group {security_group_id} is attached to Classic ELB: {lb['LoadBalancerName']}")
                                  return True
                  except Exception as e:
                      print(f"Error checking Classic ELB associations: {str(e)}")

                  print(f"Security group {security_group_id} is not attached to any load balancer")
                  return False

              except Exception as e:
                  print(f"Error checking load balancer associations: {str(e)}")
                  # If we can't check, assume it's not attached to be safe
                  return False

          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")

              # Check if this event was generated by our remediation
              if is_event_from_remediation(event):
                  print("Skipping event as it was generated by remediation")
                  return {
                      'statusCode': 200,
                      'body': "Event was generated by remediation, skipping"
                  }

              # Get CIDR ranges from environment variable
              internal_cidr_ranges = get_internal_cidr_ranges()
              print(f"Using internal CIDR ranges: {internal_cidr_ranges}")

              # Extract security group ID from the CloudTrail event
              try:
                  if 'detail' in event:
                      event_name = event['detail']['eventName']
                      print(f"Processing event: {event_name}")

                      if event_name == 'CreateSecurityGroup':
                          target_sg_id = event['detail']['responseElements']['groupId']
                      elif event_name == 'ModifySecurityGroupRules':
                          target_sg_id = event['detail']['requestParameters']['ModifySecurityGroupRulesRequest']['GroupId']
                      elif event_name == 'AuthorizeSecurityGroupIngress':
                          target_sg_id = event['detail']['requestParameters']['groupId']
                      else:
                          raise ValueError(f"Unsupported event type: {event_name}")

                      if not target_sg_id:
                          raise ValueError("Could not determine security group ID from event")

                  else:
                      raise ValueError("Event does not contain detail section")

              except Exception as e:
                  print(f"Error extracting security group ID from event: {str(e)}")
                  return {
                      'statusCode': 400,
                      'body': f"Error processing event: {str(e)}"
                  }

              print(f"Target Security Group ID: {target_sg_id}")

              # Check if security group is attached to a load balancer
              is_lb_sg = is_sg_attached_to_load_balancer(target_sg_id)
              if is_lb_sg:
                  print(f"Security group {target_sg_id} is attached to a load balancer. Will skip specified ports.")

              # Add a small delay to allow for eventual consistency
              time.sleep(2)

              # Describe the specific security group
              try:
                  security_group = ec2.describe_security_groups(GroupIds=[target_sg_id])
                  print(f"Successfully described security group {target_sg_id}.")
              except Exception as e:
                  print(f"Error describing security group: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': f"Error describing security group: {str(e)}"
                  }

              # Flag to check if any rules were remediated
              remediation_done = False

              # Process security group rules
              for permission in security_group['SecurityGroups'][0]['IpPermissions']:
                  port = permission.get('FromPort')
                  print(f"Evaluating rule with protocol {permission['IpProtocol']}, "
                        f"ports {port if port is not None else 'All'} to {permission.get('ToPort', 'All')}.")

                  # Skip if this is a load balancer security group and the port should be skipped
                  if not should_remediate_rule(is_lb_sg, port):
                      continue

                  for ip_range in permission.get('IpRanges', []):
                      if ip_range['CidrIp'] == '0.0.0.0/0':
                          print(f"Found rule allowing ingress from 0.0.0.0/0 on ports "
                                f"{port if port is not None else 'All'} to {permission.get('ToPort', 'All')}.")

                          try:
                              # Revoke the open ingress rule
                              ec2.revoke_security_group_ingress(
                                  GroupId=target_sg_id,
                                  IpProtocol=permission['IpProtocol'],
                                  FromPort=permission.get('FromPort'),
                                  ToPort=permission.get('ToPort'),
                                  CidrIp='0.0.0.0/0'
                              )
                              print(f"Revoked rule allowing ingress from 0.0.0.0/0 on ports "
                                    f"{port if port is not None else 'All'} to {permission.get('ToPort', 'All')}.")

                              # Add new rules for internal CIDR ranges
                              for cidr in internal_cidr_ranges:
                                  ec2.authorize_security_group_ingress(
                                      GroupId=target_sg_id,
                                      IpProtocol=permission['IpProtocol'],
                                      FromPort=permission.get('FromPort'),
                                      ToPort=permission.get('ToPort'),
                                      CidrIp=cidr
                                  )
                                  print(f"Authorized rule allowing ingress from {cidr} on ports "
                                        f"{port if port is not None else 'All'} to {permission.get('ToPort', 'All')}.")

                              remediation_done = True

                          except Exception as e:
                              print(f"Error modifying security group: {str(e)}")
                              return {
                                  'statusCode': 500,
                                  'body': f"Error modifying security group: {str(e)}"
                              }

              if not remediation_done:
                  print(f"No applicable rules found for remediation in security group {target_sg_id}.")
                  return {
                      'statusCode': 200,
                      'body': f"No remediation necessary for security group {target_sg_id}."
                  }

              print(f"Applicable rules for security group {target_sg_id} have been remediated.")
              return {
                  'statusCode': 200,
                  'body': f"Rules for security group {target_sg_id} have been remediated."
              }
      Environment:
        Variables:
          INTERNAL_CIDR_RANGES: !Ref InternalCIDRRanges
          ADDITIONAL_SKIP_PORTS: !Ref AdditionalSkipPorts
      Timeout: 30
      MemorySize: 128
      Tags:
        - Key: CreatedBy
          Value: !Ref 'AWS::StackName'
        - Key: StackId
          Value: !Ref 'AWS::StackId'
        - Key: StackSetName
          Value: !If [IsStackSet, !Select [0, !Split ["-", !Ref 'AWS::StackName']], "N/A"]
        - Key: CreatedMethod
          Value: !FindInMap [DefaultTags, Tags, CreatedMethod]

  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecurityGroupManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:RevokeSecurityGroupIngress
                  - ec2:AuthorizeSecurityGroupIngress
                  - elasticloadbalancing:DescribeLoadBalancers
                  - elasticloadbalancing:DescribeLoadBalancerAttributes
                  - elasticloadbalancingv2:DescribeLoadBalancers
                  - elasticloadbalancingv2:DescribeLoadBalancerAttributes
                Resource: '*'
      Tags:
        - Key: CreatedBy
          Value: !Ref 'AWS::StackName'
        - Key: StackId
          Value: !Ref 'AWS::StackId'
        - Key: StackSetName
          Value: !If [IsStackSet, !Select [0, !Split ["-", !Ref 'AWS::StackName']], "N/A"]
        - Key: CreatedMethod
          Value: !FindInMap [DefaultTags, Tags, CreatedMethod]

  SecurityGroupEventRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Name: security-group-changes
      Description: 'Capture security group modifications and creations'
      EventPattern:
        source:
          - aws.ec2
        detail-type:
          - AWS API Call via CloudTrail
        detail:
          eventSource:
            - ec2.amazonaws.com
          eventName:
            - AuthorizeSecurityGroupIngress
            - CreateSecurityGroup
            - ModifySecurityGroupRules
      State: ENABLED
      Targets:
        - Arn: !GetAtt SecurityGroupRemediationLambda.Arn
          Id: SecurityGroupRemediationTarget

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref SecurityGroupRemediationLambda
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SecurityGroupEventRule.Arn

Outputs:
  LambdaArn:
    Description: 'ARN of the created Lambda function'
    Value: !GetAtt SecurityGroupRemediationLambda.Arn
  EventRuleArn:
    Description: 'ARN of the created EventBridge rule'
    Value: !GetAtt SecurityGroupEventRule.Arn
  ConfiguredCIDRRanges:
    Description: 'Configured internal CIDR ranges'
    Value: !Ref InternalCIDRRanges
  ConfiguredSkipPorts:
    Description: 'Configured ports to skip for load balancer security groups'
    Value: !Ref AdditionalSkipPorts
